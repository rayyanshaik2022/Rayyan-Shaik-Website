<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on Rayyan Shaik</title>
    <link>https://rayyanshaik.com/tags/algorithm/</link>
    <description>Recent content in algorithm on Rayyan Shaik</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 07 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://rayyanshaik.com/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mathematical Expression Evaluator</title>
      <link>https://rayyanshaik.com/blog/calculator/</link>
      <pubDate>Wed, 07 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rayyanshaik.com/blog/calculator/</guid>
      <description>Description This repository features 2 programs that can solve mathematical expressions. Both projects were planned and thought out before writing, and my partner, Andrew Diab, and I each wrote one implementation. The first one, under the subdirectory /Dijkstra was completed by Andrew Diab - this implements the Shunting-Yard Algorithm by Edsger Dijkstra, and the simpleSolve() method created by myself. I created the second implementation found under the subdirectory Recursive. This program contains a class which can solve unordered mathematical expressions folling PEMDAS (no brackets or parentheses) under the method simpleSolve().</description>
    </item>
    
    <item>
      <title>Perlin Noise Map Generator</title>
      <link>https://rayyanshaik.com/blog/perlinmap/</link>
      <pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rayyanshaik.com/blog/perlinmap/</guid>
      <description>Description A map generating script primarly using the perlin noise equations. This program utilizes a the 2d perlin noise equation to generate topographic values in a 2d list. These values are normalized and assigned a &amp;ldquo;color output&amp;rdquo; depending on their value (for example, a low value would mean blue or water, while a high value might be grey for mountains). This program also uses poisson disc sampling to randomly generate trees across the landmasses.</description>
    </item>
    
    <item>
      <title>Boids Flocking Algorithm</title>
      <link>https://rayyanshaik.com/blog/boids-flocking/</link>
      <pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rayyanshaik.com/blog/boids-flocking/</guid>
      <description>Description My implementation of the boids flocking algorithm in pygame. It uses arrows - representative of birds - as enties that move around and account for each other&amp;rsquo;s positions. Some additional features that I implemented include an &amp;ldquo;infinite border&amp;rdquo; - meaning borders transport entities to opposite ends of the map. The entities also spawn with random hues (color), and when several enities converge into a group, their colors average out. When these groups disband, the entities slowly revert to their original color.</description>
    </item>
    
    <item>
      <title>Sorting Visualizer</title>
      <link>https://rayyanshaik.com/blog/sorting-visualizer/</link>
      <pubDate>Sun, 12 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rayyanshaik.com/blog/sorting-visualizer/</guid>
      <description>Description A project that serves as a visual representation for bubble sort, insertion sort, selection sort, and quick sort.
Github Repository The Github repository can be found here
What were my goals with this project?  Custom buttons Practice writing sorting algorithms Minimalist and attractive graphics Object-Oriented approach  Project Images    Dependencies  Pygame  </description>
    </item>
    
    <item>
      <title>A* Pathfinding</title>
      <link>https://rayyanshaik.com/blog/astar-pathfinding/</link>
      <pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rayyanshaik.com/blog/astar-pathfinding/</guid>
      <description>Description An implementation of the A* Pathfinding Algorithm. The logic behind this algorithm is based on the function f(n) = g(n) + h(n). Where the total cost of &amp;ldquo;moving&amp;rdquo; is the sum of the cost of the path to the starting node and the cost as calculated by the heuristic function for the cheapest path from the next node to the goal.
Github Repository The Github repository can be found here</description>
    </item>
    
  </channel>
</rss>
